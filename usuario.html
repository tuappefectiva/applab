<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Usuario – Laboratorio</title>
</head>
<body>

  <h1>Usuario – Laboratorio</h1>

  <h3>Buscar producto o código</h3>
  <!-- Buscador escribible (+ datalist de sugerencias). Sin clases, sin estilos nuevos. -->
  <input id="buscadorProducto" list="listaProductos" placeholder="Escribe para buscar…" autocomplete="off" />
  <datalist id="listaProductos"></datalist>

  <h3>Productos seleccionados</h3>
  <ul id="productosSeleccionados"></ul>

  <button type="button" id="hacerPedidoBtn">Hacer pedido</button>

  <script>
  document.addEventListener('DOMContentLoaded', function () {
    // =======================
    //  CONFIGURACIÓN
    // =======================
    // 1) Sustituye la primera URL por TU RAW de GitHub si usas GitHub.
    // 2) La segunda es fallback local (misma carpeta que usuario.html).
    const DATA_URLS = [
      'https://raw.githubusercontent.com/USUARIO/REPO/RAMA/ruta/productos_usuario_limpio.json', // <-- tu RAW aquí
      'productos_usuario_limpio.json'
    ];

    const OLD_SELECT_ID = 'productoSelect';           // si existía, lo eliminamos
    const SEARCH_ID     = 'buscadorProducto';
    const DATALIST_ID   = 'listaProductos';
    const LIST_ID       = 'productosSeleccionados';
    const PEDIDO_BTN_ID = 'hacerPedidoBtn';

    // =======================
    //  LIMPIEZA: eliminar primer desplegable si existiera
    // =======================
    const oldSelect = document.getElementById(OLD_SELECT_ID);
    if (oldSelect && oldSelect.parentElement) {
      oldSelect.parentElement.removeChild(oldSelect);
    }

    // =======================
    //  REFERENCIAS
    // =======================
    const searchInput = document.getElementById(SEARCH_ID);
    const dataList    = document.getElementById(DATALIST_ID);
    const listEl      = document.getElementById(LIST_ID);
    const hacerBtn    = document.getElementById(PEDIDO_BTN_ID);

    // Estado
    let productos = [];                          // [{nombre, codigo}]
    const byCodeExact = new Map();               // código tal cual -> producto
    const byCodeNorm  = new Map();               // código normalizado -> producto
    const selectedMap = new Map();               // código -> { cantidad, el, nombre }

    // Aviso si se abre con file:// (fetch no funcionará)
    if (location.protocol === 'file:') {
      console.warn('Abierta con file://. Usa un servidor (http://) para que fetch funcione.');
      info('⚠️ Abre la página desde un servidor (http://). Con file:// no se podrán cargar los productos.');
    }

    // =======================
    //  CARGAR PRODUCTOS (RAW GitHub -> fallback local)
    // =======================
    (async function cargarProductos() {
      try {
        const { text, urlUsada } = await fetchFirstAvailable(DATA_URLS, { cache: 'no-store' });
        productos = parseProductosFlexible(text);
        productos.forEach(p => {
          byCodeExact.set(p.codigo, p);
          byCodeNorm.set(normalize(p.codigo), p);
        });
        console.log(`✅ Productos cargados: ${productos.length} (desde ${urlUsada})`);
        searchInput.disabled = false;
      } catch (err) {
        console.error('No se pudieron cargar los productos:', err);
        info('❌ Error cargando el archivo de productos. Revisa el enlace RAW o el archivo local.');
        searchInput.disabled = true;
      }
    })();

    // =======================
    //  BÚSQUEDA Y ADICIÓN
    // =======================
    // Filtrado por “contiene” (nombre o código), ignorando acentos y mayúsculas.
    // Soporta múltiples palabras: todas deben aparecer.
    searchInput.addEventListener('input', () => {
      const val = searchInput.value;
      const norm = normalize(val);
      renderDatalist(norm);

      // Si el usuario selecciona una opción del datalist, el valor será el CÓDIGO.
      // Añadimos en cuanto el valor coincida con un código (sin distinguir mayúsculas/acentos).
      if (byCodeNorm.has(norm) || byCodeExact.has(val)) {
        const prod = byCodeNorm.get(norm) || byCodeExact.get(val);
        addProducto(prod);
        searchInput.value = '';
        dataList.innerHTML = '';
      }
    });

    // Por si 'change' se dispara con elecciones del datalist en algunos navegadores
    searchInput.addEventListener('change', () => {
      const val = searchInput.value;
      const norm = normalize(val);
      if (byCodeNorm.has(norm) || byCodeExact.has(val)) {
        const prod = byCodeNorm.get(norm) || byCodeExact.get(val);
        addProducto(prod);
        searchInput.value = '';
        dataList.innerHTML = '';
      }
    });

    // (Opcional) "Hacer pedido" - ahora mismo solo muestra el payload
    if (hacerBtn) {
      hacerBtn.addEventListener('click', () => {
        const pedido = Array.from(selectedMap.entries()).map(([codigo, o]) =>
          ({ codigo, nombre: o.nombre, cantidad: o.cantidad })
        );
        console.log('Pedido listo para enviar:', pedido);
        // TODO: integrar con tu backend y, si procede:
        // resetSeleccion();
      });
    }

    // =======================
    //  FUNCIONES
    // =======================

    // Intenta hacer fetch de la primera URL que funcione
    async function fetchFirstAvailable(urls, fetchOpts) {
      let lastError = null;
      for (const url of urls) {
        try {
          const r = await fetch(url, fetchOpts);
          if (r.ok) {
            const text = await r.text();
            return { text, urlUsada: url };
          } else {
            lastError = new Error(`HTTP ${r.status} en ${url}`);
          }
        } catch (e) {
          lastError = e;
        }
      }
      throw lastError || new Error('No se pudo obtener ninguna de las URLs proporcionadas.');
    }

    // --- Parseo flexible ---
    // 1) Intenta JSON (array u objeto con {productos|items|data}).
    // 2) Si no, parsea texto con pares "nombre ... codigo ...".
    function parseProductosFlexible(text) {
      // Intento 1: JSON
      try {
        const data = JSON.parse(text);
        const arr = normalizeJsonProducts(data);
        if (Array.isArray(arr) && arr.length) return arr;
      } catch (_) {}
      // Intento 2: texto "nombre ... codigo ..."
      return parseNombreCodigo(text);
    }

    // Normaliza estructuras JSON a [{nombre, codigo}]
    function normalizeJsonProducts(data) {
      const list = Array.isArray(data) ? data
                : Array.isArray(data?.productos) ? data.productos
                : Array.isArray(data?.items) ? data.items
                : Array.isArray(data?.data) ? data.data
                : null;
      if (!list) return [];
      return list.map(x => {
        if (typeof x === 'string') {
          const m = x.match(/^(.*?)[\s—-]+\s*([^\s]+)\s*$/);
          return m ? { nombre: m[1].trim(), codigo: m[2].trim() } : null;
        }
        if (x && typeof x === 'object') {
          const nombre = x.nombre ?? x.name ?? x.titulo ?? x.title;
          const codigo = x.codigo ?? x.code ?? x.sku ?? x.id;
          if (nombre && codigo) return { nombre: String(nombre), codigo: String(codigo) };
        }
        return null;
      }).filter(Boolean);
    }

    // Parser de texto: “nombre … codigo …”
    function parseNombreCodigo(text) {
      const productos = [];
      const re = /nombre\s+([\s\S]+?)\s+codigo\s+([^\s]+)/gi;
      let m;
      while ((m = re.exec(text)) !== null) {
        const nombre = m[1].trim().replace(/\s+/g, ' ');
        const codigo = m[2].trim();
        if (nombre && codigo) productos.push({ nombre, codigo });
      }
      return productos;
    }

    // Normaliza cadenas para comparar (sin acentos, mayúsculas)
    function normalize(s) {
      return (s || '')
        .normalize('NFD').replace(/\p{Diacritic}/gu, '')
        .toUpperCase().trim();
    }

    // Renderiza opciones del datalist filtrando por “contiene”
    // Soporta múltiples palabras: todas deben aparecer en (nombre + código)
    function renderDatalist(termNorm) {
      const MAX_OPTS = 200;
      dataList.innerHTML = '';

      const terms = termNorm.split(/\s+/).filter(Boolean);
      if (!terms.length) return;

      const results = productos.filter(p => {
        const haystack = normalize(p.nombre + ' ' + p.codigo);
        return terms.every(t => haystack.includes(t));
      });

      results.sort((a, b) => score(a, terms) - score(b, terms));

      for (let i = 0; i < Math.min(results.length, MAX_OPTS); i++) {
        const p = results[i];
        const opt = document.createElement('option');
        opt.value = p.codigo;                       // lo que se inserta en el input
        opt.label = `${p.nombre} — ${p.codigo}`;    // lo que se ve en la lista
        dataList.appendChild(opt);
      }
    }

    // Puntuación sencilla para ordenar coincidencias
    function score(p, terms) {
      const n = normalize(p.nombre);
      const c = normalize(p.codigo);
      const joined = n + ' ' + c;
      // Priorizar: empieza por código/nombre > contiene en código > contiene en nombre
      const startsCode = terms.every(t => c.startsWith(t)) ? 0 : 999;
      const startsName = terms.every(t => n.startsWith(t)) ? 1 : 999;
      const inCode     = terms.every(t => c.includes(t))   ? 2 : 999;
      const inName     = terms.every(t => n.includes(t))   ? 3 : 999;
      const inAny      = terms.every(t => joined.includes(t)) ? 4 : 999;
      return Math.min(startsCode, startsName, inCode, inName, inAny);
    }

    // Añade o incrementa un producto en la lista de seleccionados
    function addProducto(p) {
      if (selectedMap.has(p.codigo)) {
        const entry = selectedMap.get(p.codigo);
        entry.cantidad += 1;
        const qtyEl = entry.el.querySelector('[data-role="cantidad"]');
        if (qtyEl) qtyEl.textContent = entry.cantidad;
        return;
      }
      const li = document.createElement('li');
      li.innerHTML = `
        <span>
          <strong>${escapeHtml(p.nombre)}</strong>
          — <code>${escapeHtml(p.codigo)}</code>
          · x<span data-role="cantidad">1</span>
        </span>
        <button type="button" data-role="remove" aria-label="Quitar ${escapeHtml(p.nombre)}">Quitar</button>
      `;
      li.querySelector('[data-role="remove"]').addEventListener('click', () => {
        selectedMap.delete(p.codigo);
        li.remove();
      });
      listEl.appendChild(li);
      selectedMap.set(p.codigo, { cantidad: 1, el: li, nombre: p.nombre });
    }

    function resetSeleccion() {
      selectedMap.clear();
      listEl.innerHTML = '';
      searchInput.value = '';
      dataList.innerHTML = '';
    }

    function escapeHtml(s) {
      return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }

    function info(texto) {
      const p = document.createElement('p');
      p.textContent = texto;
      // Sin clases ni estilos para no alterar tu diseño
      document.body.appendChild(p);
    }
  });
  </script>
</body>
</html>
